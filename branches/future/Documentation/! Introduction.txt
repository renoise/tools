--[[----------------------------------------------------------------------------
-- Renoise Scripting Reference and HOWTOs - Introduction
----------------------------------------------------------------------------]]--

Welcome to the Renoise scripting Guide. In all the various files in this
"Documentation" folder, we will give you an overview on how to write scripts
and extensions for Renoise; how to debug them, what's possible to "script",
what's not, and much more. Please read this introduction carefully, to get an
idea how to get started, and to avoid common pitfalls and questions.


--------------------------------------------------------------------------------
-- Scripting Development Tools in Renoise
--------------------------------------------------------------------------------

By default Renoise has all the scripting stuff hidden to keep things as easy as
possible for those who don't want to mess around with code. If you want to write
scripts, the first thing you have to do is enable the hidden development tools
that are built into Renoise. This can be done by:

- launching the Renoise executable with the argument "--scripting-dev"

- open Renoise's config.xml file from the preferences folder, and set the
  <ShowScriptingDevelopmentTools> property to "true". This way, you don't have
  to pass the above argument all the time...

Enabling this option will add a new main menu entry "Tools" (or add new
entries there if it already exists). In the "Tools" menu you will find:

- "Reload All Tools": This will force a reload of all installed and running
  scripting tools (extensions). This can be handy when adding new tools by hand
  or when changing them.

- "Scripting Console & Editor": This is the main developing scripting tool. It
   allows you to:
  + Evaluate scripts or commands in realtime with a small terminal (command-line)
  + Watch any scripts output (all "print"s and errors from scripts will be
    redirected here)
  + Create, view and edit Lua, text, and XML files that will
    make up tools / extensions for Renoise. More about this later...

- "Example Tools" and other tools that target script developers only.


--------------------------------------------------------------------------------
-- What can be 'scripted', what can't? What is all this 'scripting' about?
--------------------------------------------------------------------------------

Right now (in this Renoise release), you can make use of scripts in the
following places:

- Run scripts and commands via a terminal in realtime using the
  "Scripting Console & Editor". This is what enabling "--scripting-dev" will
  do and how you will start getting into all this...

- Create Tools, Extensions: Add new and custom functionality to Renoise.
  Tools are small file bundles with a Lua script and a description file
  (manifest.xml) that make use of the Renoise API; described below.
  Such tools can be distributed and installed via drag and drop (by bundling
  them and hiding the code). This way, not only developers can use them, but
  also those who don't want to mess around with the technical details. We'll
  describe bundles later on in detail.

  Some examples of what you can do with Renoise tools and extensions:

  + Like for example in Firefox or Thunderbird, you can create new context menu
    entries and keyboard shortcuts (add "My Better Jump in Pattern by X Lines"
    keybinding, "My Bypass all Devices in Track" entries in the DSP chain,
    "My Generate Chip Sound Sample" in the Sample Editor and so on...)

  + Create custom graphical user interfaces that look and behave like Renoise.
    Perfectly integrate your tools into Renoise and make them as easy to use
    for all others. Extend Renoise with new features that look like everything
    else in Renoise.

  + Manipulate Renoise's main window (Application) or the Song (patterns,
    tracks, instruments, anything that makes up a song). Create, filter, do
    whatever with any existing song data, like algorithmic composing, instrument
    creation, "automation", whatever you can imagine and need...

  + Add custom file Import handlers (add support for new filetypes)

  + Nibbles ;)

- You can also create bidirectional MIDI, OSC implementations for any controller
  hardware:
  Make your Launchpad behave and do exactly what you want it to do, and share
  your settings with others. Such tools can be a simple auto mapping of your
  MIDI controller, like support for Mackie Controls, Behringer MIDI Mixers and
  so on without having to "map" anything manually in Renoise -> plug and play.
  Create MIDI mappings or an OSC implementation the way you need it for live
  sessions or other needs.

- Create, configure, or override Renoise's default MIDI, OSC bindings:
  Renoise has a default set of MIDI mappings that can be assigned manually by
  the user. This set can be extended and tweaked to fit your needs, then via
  the MIDI Mapping Dialog in Renoise used and mapped as usual.
  Renoise also has a default OSC implementation which you can tweak and override
  to do "your stuff."

What you can *NOT* do with Renoise tools and extensions:

  + Change Renoise's existing behaviour. Like, you can not make all C-4s in the
    pattern editor yellow instead of white. You can write your own pattern
    editor, but not change the existing one.

  + "Realtime" access. Except the OSC and MIDI IO stuff, you can not not
    write scripts that run in the player. So you can not script your own new
    realtime DSP - yet. But you can, for example, write a tool that creates
    samples or manipulates existing samples. This limitation might change in
    future. For now make a VST or AudioUnit. One thing after the other please.


--------------------------------------------------------------------------------
-- Renoise Lua API overview
--------------------------------------------------------------------------------

The XXX.API.txt files in this documentation folder will list all available Lua
functions and classes that you can access from scripts in Renoise.
If you are familiar with Renoise, the names of the classes, functions and
properties should hopefully explain themselves (WYSIWYG).

Here is a small overview of the whole API that Renoise exposes:

-- Renoise API version number and some global accessors "song", "app" are here
* Renoise.API

-- access to the main Renoise application and window, main user interface
* Renoise.Application.API

-- access to the song and all its components (instruments, samples, tracks...)
* Renoise.Song.API

-- generic "observer pattern" document creation and access, used by the
   song/app and also by you to create persistent data that can even be injected
   into Renoise songs
* Renoise.Document.API

-- inter-process and network communication functions and classes (also for OSC)
* Renoise.Socket.API

-- "raw" MIDI device interaction (send, receive MIDI messages)
* Renoise.Midi.API


Some notes about the used notation in !all xxxAPI.txt! files:

* All classes, functions are nested in a namespace (Lua table) "renoise". e.g:
  to get the application object, you will have to type "renoise.app()"

* The API is object orientated, and thus split into classes. The references
  will first note the class name (i.g: 'renoise.Application'), then list its
  properties / functions.
  All properties and functions are always listed with their full path to make
  clear where they belong to, how to access them...

* return values (or arguments / types of properties) are listed in brackets.
  -> [string] means that a string is returned. When no brackets are listed,
  the function will not return anything.

* Nearly are functions are actually "methods", so you have to invoke them
  via the colon operator ":" 'renoise.app():show_status("Status Message")'
  If you're new to Lua, this takes a while to get used to. Don't worry, this
  will make sense sooner or later ;)

* Properties are syntactic sugar for get/set functions. "song().comments"
  will invoke a function which returns "comments". But not all properties do
  have setters, and thus can only be used as read-only "getters". Those are
  marked as [read-only, type].
  Again mind the colon, which you !don't! have to use with properties!

* All exposed "objects" are read-only (you can not add new fields, properties),
  but the "classes" are not. This means you can extend the API classes with your
  own helper functions, if needed, but can not add new properties to the objects.
  "objects", like for example the result of "song()" are read-only, to make
  it easier to catch typos: 'song().transport.bmp = 80' will fire an error,
  because there is no such property 'bmp.' You probably meant
  'song().transport.bpm = 80' here. If you need to store data somewhere, simply
  do it in your own tables, objects, instead of using the Renoise API objects.

* "some_property, _observable" means, that there is also an observer object
  available for the property. An observable object allows you to attach notifiers
  (global functions or methods) that will be called as soon as its value
  has changed. Please see Renoise.Document.API.txt for more info about observables
  and related classes.

  -- one small example for bpm:
  renoise.song().transport.bpm_observable:addnotifier(function()
    print("bpm changed")
  end)

  -- will print "bpm changed", but only if the bpm was not 120 before (it changed)
  renoise.song().transport.bpm = 120

  your notifier is called when !anything! changes the bpm, including
  your script, other scripts, or anything else in the Renoise (you've
  automated the BPM in the song, entered a new BPM value in Renoise's GUI,
  whatever)...

  - lists like "renoise.song().tracks[]" can also have notifiers. But those
  will only fire when the !list layout! has changed: an element was added,
  removed or elements in the list changed their order. They will !not! fire when
  the list values changed. Attach notifiers to the list elements to get such
  notifications.

* Can't remember what the name of function XYZwas? In the scripting terminal you
  can list all methods/properties of API objects (or your own class objects)
  via the global function 'oprint(some_object)' - i.g 'oprint(renoise.song())'
  To dump the renoise module/class layout, use 'rprint(renoise)'


--------------------------------------------------------------------------------
-- Creating Renoise Tools, Extensions
--------------------------------------------------------------------------------

TODO: After the Bundle Format changes



--------------------------------------------------------------------------------
-- Debugging Renoise Scripts
--------------------------------------------------------------------------------

If tracing / debugging in the console with print, oprint and rprint isn't
enough, you can also attach a command-line based debugger to your script. Please
have a look at Debugging.txt for more information and a small tutorial.


-- Enjoy extending, customizing and automating Renoise ;)

--[[----------------------------------------------------------------------------
----------------------------------------------------------------------------]]--


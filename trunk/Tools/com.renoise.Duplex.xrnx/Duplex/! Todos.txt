================================================================================
Duplex Changelog, Notes & TODOs
================================================================================

--------------------------------------------------------------------------------
In Progress
--------------------------------------------------------------------------------

* Bjorn: Make the virtual control surface detect press/release

* Bjorn: MixConsole option: Show only certain track types 

* Bjorn: Re-animate Device options parsing

* Eduard: Implement Behringer BFC and BFR classes, finish the control maps

* Eduard: Relative MIDI controller message support for encoders

* Eduard: find and load controllers and apps dynamically


================================================================================
Planned / Todo
================================================================================

Before beta starts

* [danoise]: share track and other "offsets" for multiple running apps 
* [danoise]: implement the "Navigator" app 
* [danoise]: add Pitchbend support, and generic channel mapping -> [CC23|2]
* [danoise]: start with the APC controller support

--

* Navigator
  o Extract code from other apps

* OSC Device / protocol support

* Ability to map any app option?

* New Applications
  o FX parameter Mixer (control currently selected FX)

* MixConsole: 
  o Support "OFF" and "MUTE" modes (which depend on Renoise preference)

* Application configuration panel:
  o List the names of application groups, each with "choose" button that open
    a slightly smaller version of the virtual UI for choosing the relevant
    control and/or group
  o Other options listed as a popup (the active choice)

* Device control-panel: 
  o Small (optional) thumbnail for device
  o Release/initialize device
  o Select among available control-map layouts (obtain list by scanning folder)
  o Display controlmap info (author, name, description) 
  o Reload control-map
  o Set control-map as standard (persistent setting)
  o MidiDevice: specify input port - only for devices that 
    doesn't have a dedicated class (remember the chosen port)
  o OSCDevice: specify the prefix (could be /renoise or /duplex always?)
  o Advanced settings tab (i.e. control brightness, contrast) - expose these 
    settings via generic "options" table in the device class

* ControlMap: <Page> node, indicates that multiple pages with identical layout
  can be expected (useful for access to the full mapping/MIDI implementation 
  of e.g. the Nocturn controller). Question: could the <Page> node become 
  problematic, in case that the controller doesn't switch ALL of it's parameters
  when a new page is entered? (on the other hand, there's no reason we can't 
  repeat values across pages?)

* Scheduler class: for double-press detect, and stuff like blinking objects
  o PatternMatrix: the scheduled pattern should blink

* UITrigger: trigger button (with short delay, needs the Scheduler)
  o Delay time (0 for cycle mode, 100 for quick fade)
  o Colors (list)
    o Use as "fading effect" when a short delay is specified
    o In cycle mode, switch on each hit 

* PatternMatrix: create a dedicated class for sequence triggers (UITrigger),
  complete with "blinking" and "shaded loop region"
  o Active pattern index (press)
  o Scheduled pattern index (press another button than the selected one)
  o Looped range (press button, hold and then press another button)

* "Soft-validate" the control-map - warn when required elements are missing, 
  but ignore unknown ones

* Display:clear(): when a device is closed, call this function (should use 
  some hardware-specific feature if possible)

* Improve application performance by removing UIComponent listeners when
  application is stopped, and re-attach on startup. This will also help to
  simplify the code, as the numerous checks for "self.active" in event-handlers 
  is no longer needed

* Browser: option for keeping devices in separate streams (should run faster)

* Specify color-space per control-map group (not all buttons are born equal)
* Specify unit-size per control-map group (not all buttons are born equal)

* Optimize: only compute palettes when dealing with a colorspace


--------------------------------------------------------------------------------
Discuss
--------------------------------------------------------------------------------

* Meta-applications / apps talking to each other?
  Expose the device process (all running apps on the device)

* MixConsole makes "MUTE" (not "OFF") impossible !!
  Check when a track is muted, the type of mute and set mode accordingly

* Do we have access method for normal renoise mappings through Duplex?
  How hard to make such an application? (Answer)

* How settings are saved / persistent storage

* Ability to perform automation recording (using global Renoise API switch)
  Record any parameter exposed by the API?

* Ability to "discard" incoming messages after they have been processed (or 
  there would be note-on and cc messages all over the place). 

================================================================================
Done
================================================================================

* Selective display updates: change only the values that are needed

* Improved how meta-attributes are added to external control-map files. 
  They are now added as the XML is parsed - previously it was the VirtualDisplay
  class that did this.

* Tooltips when hovering over controls: displays "name (value)"

* Support rotary encoder and sliders as input method (via Mini/Slider 
  widget in Renoise):
  o Summing control values into a Slider's value, when the input method 
    isn't "button"
  o VirtualDisplay: when a slider is represented by several MiniSlider's, the 
    only way to update the visual representation is to supply the MiniSlider's
    with new values. However, we are also listening for those values, so 
    there's a loop. This would not happen if we were able to set the value 
    independently ? UPDATE: solved by having a table of notifier methods, so
    we can add and remove listeners while updating values programatically. 
    See also this thread: 
    http://www.renoise.com/board/index.php?showtopic=24685&st=0&#entry194226
    
* Use os.currentdir for class paths

* Basic MIDI input/output

* Point class (represents a canvas point/unit (text,color) 

* Merge Virtual/Hardware classes into the Display class

* Application class methods for switching between applications/putting to 
  sleep etc.

* Convert existing tools into Application classes (MixConsole, PatternMatrix)

* Dynamic switching of MIDI device and control-map 

* MidiDevice: improved implementation of "color-to-value" (now called 
  point-to-value)

* It's possible to spawn multiple dialog windows (and cause Renoise to crash)¨

* Detect tool menu item arguments after the initial script has been 
  launched (currently, the dialog is simply displayed)

* ControlMap: <Param> @type="fader",  needed in order to emulate the 
  Nocturn/Ohm64. It could work much like the "rotary", but will occupy more
  units on the control surface (the "size" attribute) and have either a 
  vertical or horizontal orientation

* Make it possible to cancel events on the UIComponent level (implement a 
  handler method that return a boolean value, and revert any changes to the 
  UIComponent if the function returns a false value), Is there a smarter way to 
  do this than manually rolling back to a previous state. Like, a way to 
  define a "frozen state" of the UIComponent so we may simply do a 
  self.revert() ?

* Renamed Point class to CanvasPoint, merged with Canvas class

* Merged Message class with MessageStream class

* MessageStream: Hold event now detected

* Branch future: Display: Add support for vertical faders in Virtual UIs

* Fixed missing/bogus attaching to tracks in the mixer when the track count 
  changed or the tracks got reordered
 
* Observable references disappear when loading new song. Implement & Test 
  standard method for reassigning on new document notification
   
* Use class:method syntax

* Fixed issue with UISlider (not getting right index value when flipped)

* Fixed UISlider.inverted, wrong name, should be "flipped" (in MixConsole)

* Added support for pitch bend (specified as <param @type="PB">)

* Removed references to "CONTROLLER_ENCODER" (it was never actually used)

* Renamed constant CONTROLLER_POT to CONTROLLER_DIAL 

* PatternMatrix: when trigger-group is an ampty string, embed into matrix 
  (if the trigger-group is undefined, do not create triggers at all)

* MixConsole/PatternMatrix: build_app() called when started, not loaded
  (to avoid that UIComponents are created before they are actually used)

* Dynamic menu entries (pinned scripts) - controlled from app options

* Keyboard shortcut to Browser 

* Application aliases - multiple instances of app on the same device

* MIDI Dump (as menu option)

* Application class : apply_mappings/options() methods

--

* Fixed, MixConsole: Ohm64/VolumeLeft is used for mute switching? 
  (mutes were incorrectly reported as a grid)

* Nocturn.lua : set feedback property explicitly in class

* Removed Device.palette (obsolete property)

-- 7/8/2010

- general code cleanup, API doc summaries added to most classes
- ohm64: crossfader acting as sequence navigator (please verify)?

* MixConsole/PatternMatrix
  o most properties made private (underscored)

* MixConsole: 
  o fixed "master" notifier (when changed in Renoise)
  o renamed some properties, restructured color support
  o fixed a bug when changing number of tracks (color not changed)
  o proper embed controls (mute/master) in grid mode

* UISpinner: some improvements before it can be used as Navigator control
  o support for dials/faders as input method*
  o text orientation property, arrows as part of palette (easier to set up)
  * set __size to 1 for "proper dial mode" ;)


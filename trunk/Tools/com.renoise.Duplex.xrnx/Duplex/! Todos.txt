================================================================================
Duplex Changelog, Notes & TODOs
================================================================================

--------------------------------------------------------------------------------
Bugs
--------------------------------------------------------------------------------

* [danoise]: Multiple grid/column group layouts are broken (use Ohm64 for testing). 
  Groups are not closed before the next one is encountered

* [danoise]: MixConsole: Ohm64/VolumeLeft is used for mute switching? 

* [taktik]: function BrowserProcess:__finalize() causes a pure virtual function 
  call error when destroying the scripting engine


--------------------------------------------------------------------------------
In Progress
--------------------------------------------------------------------------------

* [kraken]: finalize Apps and configs for the OHM

* [taktik + danoise]: implement OSC server message cracking for the Monome, add 
  support for the Monome

* [taktik]: Document or add option to send the default presets we use for the 
  controllers via a sysex dump

* [taktik]: Implement Behringer BFC and BFR classes, finish the control maps

* [taktik]: find and load controllers and apps dynamically

* ???: New Applications
  o FX parameter Mixer (control currently selected FX)
  o Transport (control Play/Start/Stop/Bla)

* ???: MixConsole: 
  o Support "OFF" and "MUTE" modes (which depend on Renoise preference)

* ???: Relative MIDI controller message support for encoders

* ???: Add an persistant option to "autostart" configurations, so users don't 
  have to launch and configure Duplex over and over again for "their" setup
  

================================================================================
Planned / Todo
================================================================================

* Add support for Pitchbend messages
  Note: We do need to pass over the MIDI channel in the control maps here as 
  well. This maybe will also be needed for CC messages, because some controllers 
  might use multiple channels within a single preset. For PB this is definitely 
  needed, cause there are only 16 PB streams (there is no PB number, like with 
  CC). i.g: The Mackie control uses 8 PBs for its main volume faders...

* Make MessageStream detect more event types: release, etc.

* Application configuration panel:
  o List the names of application groups, each with "choose" button that open
    a slightly smaller version of the virtual UI for choosing the relevant
    control and/or group
  o Other options listed as a popup (the active choice 

* Device control-panel: 
  o Small (optional) thumbnail for device
  o Release/initialize device
  o Select among available control-map layouts (obtain list by scanning folder)
  o Display controlmap info (author, name, description) 
  o Reload control-map
  o Set control-map as standard (persistent setting)
  o MidiDevice: specify input port - only for devices that 
    doesn't have a dedicated class (remember the chosen port)
  o OSCDevice: specify the prefix (could be /renoise or /duplex always?)
  o Advanced settings tab (i.e. control brightness, contrast) - expose these 
    settings via generic "options" table in the device class

* ControlMap: <Page> node, indicates that multiple pages with identical layout
  can be expected (useful for access to the full mapping/MIDI implementation 
  of e.g. the Nocturn controller). Question: could the <Page> node become 
  problematic, in case that the controller doesn't switch ALL of it's parameters
  when a new page is entered? (on the other hand, there's no reason we can't 
  repeat values across pages?)

* ControlMap: @IsBidirectional attribute, cancel output if false

* Scheduler class: for double-press detect, and stuff like blinking objects
  o PatternMatrix: the scheduled pattern should blink

* PatternMatrix: create a dedicated class for sequence triggers (UISeqTrigger)
  o Active pattern index
  o Scheduled pattern index
  o Define a looped range (press button, hold and then press another button)

* "Soft-validate" the control-map - warn when required elements are missing, 
  but ignore unknown ones

* Display:clear(): when a device is closed, call this function (should use 
  some hardware-specific feature if possible)

* Improve application performance by removing UIComponent listeners when
  application is stopped, and re-attach on startup. This will also help to
  simplify the code, as the numerous checks for "self.active" in event-handlers 
  is no longer needed

* Browser: option for keeping devices in separate streams

* Specify color-space per control-map group (not all buttons are born equal)


--------------------------------------------------------------------------------
Discuss
--------------------------------------------------------------------------------

* MixConsole makes "MUTE" (not "OFF") impossible !!
  Check when a track is muted, the type of mute and set mode accordingly

* Ability to "discard" incoming messages after they have been processed (or 
  there would be note-on and cc messages all over the place). 

* Ability to perform automation recording (using global Renoise API switch)
  Record any parameter exposed by the API?

* When switching to an application that use identical group-names as another
  app running on the same device, we want to avoid that both apps produce 
  output at the same time, or they would "fight for the same space"
  (for some context: see Browser:set_application)

================================================================================
Done
================================================================================

* Selective display updates: change only the values that are needed

* Improved how meta-attributes are added to external control-map files. 
  They are now added as the XML is parsed - previously it was the VirtualDisplay
  class that did this.

* Tooltips when hovering over controls: displays "name (value)"

* Support rotary encoder and sliders as input method (via Mini/Slider 
  widget in Renoise):
  o Summing control values into a Slider's value, when the input method 
    isn't "button"
  o VirtualDisplay: when a slider is represented by several MiniSlider's, the 
    only way to update the visual representation is to supply the MiniSlider's
    with new values. However, we are also listening for those values, so 
    there's a loop. This would not happen if we were able to set the value 
    independently ? UPDATE: solved by having a table of notifier methods, so
    we can add and remove listeners while updating values programatically. 
    See also this thread: 
    http://www.renoise.com/board/index.php?showtopic=24685&st=0&#entry194226
    
* Use os.currentdir for class paths

* Basic MIDI input/output

* Point class (represents a canvas point/unit (text,color) 

* Merge Virtual/Hardware classes into the Display class

* Application class methods for switching between applications/putting to 
  sleep etc.

* Convert existing tools into Application classes (MixConsole, PatternMatrix)

* Dynamic switching of MIDI device and control-map 

* MidiDevice: improved implementation of "color-to-value" (now called 
  point-to-value)

* It's possible to spawn multiple dialog windows (and cause Renoise to crash)¨

* Detect tool menu item arguments after the initial script has been 
  launched (currently, the dialog is simply displayed)

* ControlMap: <Param> @type="fader",  needed in order to emulate the 
  Nocturn/Ohm64. It could work much like the "rotary", but will occupy more
  units on the control surface (the "size" attribute) and have either a 
  vertical or horizontal orientation

* Make it possible to cancel events on the UIComponent level (implement a 
  handler method that return a boolean value, and revert any changes to the 
  UIComponent if the function returns a false value), Is there a smarter way to 
  do this than manually rolling back to a previous state. Like, a way to 
  define a "frozen state" of the UIComponent so we may simply do a 
  self.revert() ?

* Renamed Point class to CanvasPoint, merged with Canvas class

* Merged Message class with MessageStream class

* MessageStream: Hold event now detected

* Branch future: Display: Add support for vertical faders in Virtual UIs

* Fixed missing/bogus attaching to tracks in the mixer when the track count 
  changed or the tracks got reordered
 
* Observable references disappear when loading new song. Implement & Test 
  standard method for reassigning on new document notification
   
* Use class:method syntax

* Rotary (UIComponent)
  o meant to emulate rotary encoders on hardware
  o takes up only a single unit-space in a control-map
  o mode: absolute/relative (normal/endless)
  o precision: change this for larger internal precision

* Multi-tasking browser: keep applications running, open multiple devices at 
  the same time
  o If a device is selected
    + If another device is already selected & running an application
      # Keep the device/application running, and instantiate the new device
    + If another device is already selected, but not running an application
      # Close the other device, switch to the selected device
  o If an application is selected
    + If no application is running, start the selected application 
  o * Definition of "running application" : application is selected and "run" 
      is checked

* Fixed issue with UISlider (not getting right index value when flipped)

* Fixed UISlider.inverted, wrong name, should be "flipped" (in MixConsole)

* Added support for pitch bend (specified as <param @type="PITCHBEND"> in control-map)

* Removed references to "CONTROLLER_ENCODER" (it was never actually used)

* Renamed constant CONTROLLER_POT to CONTROLLER_DIAL 

* PatternMatrix: when trigger-group is an ampty string, embed into matrix 
  (if the trigger-group is undefined, do not create triggers at all)

* MixConsole/PatternMatrix: build_app() called when started, not loaded
  (to avoid that UIComponents are created before they are actually used)

* Dynamic menu entries (pinned scripts) - controlled from app options

* Keyboard shortcut to Browser 

* Application aliases - multiple instances of app on the same device

* MIDI Dump (as menu option)

* Application class : apply_mappings/options() methods



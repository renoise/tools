-------------------------------------------------------------------------------
-- CodeSnippets.txt
-------------------------------------------------------------------------------

--[[

Categorized collection of small LUA code snippets, to show some uses of the 
LUA API in Renoise and all its components...

For some real tools and code, have a look at the example tools 
in the Renoise package please: Scripts/Tools/Example*.lua

Please read the INTRODUCTION.txt first to get an overview about the complete
API and scripting in Renoise in general... 

--]]

error("do not even try run this file. read and copy/paste from it only...")
 

-------------------------------------------------------------------------------
-- Object Orientet Programming in LUA
-------------------------------------------------------------------------------

--[[

Renoises lua API has a simple OO support inbuilt -> class "MyClass". All 
Renoise API object use such classes.

See http://www.rasterbar.com/products/luabind/docs.html#defining-classes-in-lua
for more technical info and bolow for a simple example

Something to keep in mind:

* constructor "function MyClass:__init(args)" must be defined for each class, 
  or the classcan't be used to instantiate objects
  
* class defs are always global, so even locally defined classes will be 
  registered globally...

--]]


-- abstract class

class 'Animal'
  function Animal:__init(name)
    self.name = name
    self.can_fly = nil
  end  

  function Animal:__tostring()
    assert(self.can_fly ~= nil, "I don't know if I can fly or not")
    if self.can_fly then
      return ("I am a %s (%s) and I can fly"):format(self.name, type(self))
    else
      return ("I am a %s (%s) and I can not fly"):format(self.name, type(self))
    end
  end


-- derived classes

-- MAMMAL
class 'Mammal' (Animal)
  function Mammal:__init(str)
    Animal.__init(self,str)
    self.can_fly = false
  end

  
-- BIRD
class 'Bird' (Animal)
  function Bird:__init(str)
    Animal.__init(self,str)
    self.can_fly = true
  end


-- FISH
class 'Fish' (Animal)
  function Fish:__init(str)
    Animal.__init(self,str)
    self.can_fly = false
  end


-- run

local farm = table.create()

farm:insert(Mammal("cow"))
farm:insert(Bird("sparrow"))
farm:insert(Fish("bass"))

print(("type(Mammal('cow')) -> %s"):format(type(Mammal("cow"))))
print(("type(Mammal) -> %s"):format(type(Mammal)))

for _,animal in pairs(farm) do
  print(animal)
end


-------------------------------------------------------------------------------
-- Class operators

-- You can overload most operators in Lua for your classes. You do this by 
-- simply declaring a member function with the same name as an operator 
-- (the name of the metamethods in Lua).

--[[ The operators you can overload are:

* __add
* __sub
* __mul
* __div
* __pow
* __lt
* __le
* __eq
* __call
* __unm
* __tostring
* __len

--]]

-- "__tostring" isn't really an operator, but it's the metamethod that is 
-- called by the standard library's tostring() function. 


-------------------------------------------------------------------------------
-- Files & Bits
-------------------------------------------------------------------------------

-- reading integer numbers or raw bytes from a file

local function read_word(file)
  local bytes = file:read(2)
  if (not bytes or #bytes < 2) then 
    return nil 
  else
    return bit.bor(bytes:byte( 1),
      bit.lshift(bytes:byte(2), 8))
  end
end

local function read_dword(file)
  local bytes = file:read(4)
  if (not bytes or #bytes < 4) then 
    return nil 
  else
    return bit.bor(bytes:byte(1),
      bit.lshift(bytes:byte(2), 8),
      bit.lshift(bytes:byte(3), 16),
      bit.lshift(bytes:byte(4), 24))  
  end   
end

-- and so on (adapt as needed to mess with endianess!) ...

local file = io.open("some_binary_file.bin", "rb")

local bytes = file:read(512)

if (not bytes or #bytes < 512) then 
  print("unexpected end of file")
else
  for i = 1, #bytes do
    print(bytes:byte(i))
  end
end
    
print(read_word(file) or "unexpected end of file")
print(read_dword(file) or "unexpected end of file")


-- more bit manipulation? -> See "bit" in "StandardLuaApi.txt"


-------------------------------------------------------------------------------
-- renoise.PatternIterator
-------------------------------------------------------------------------------

-- change notes in selection
-- (all "C-4"s to "E-4" in the selection in the current pattern)

local pattern_iter = renoise.song().pattern_iterator
local pattern_index =  renoise.song().selected_pattern_index

for pos,line in pattern_iter:lines_in_pattern(pattern_index) do
  for _,note_column in pairs(line.note_columns) do 
    if (line.note_columns[1].is_selected and 
        line.note_columns[1].note_string == "C-4") then
      line.note_columns[1].note_string = "E-4"
    end
  end
end


-- generate a simple arp sequence (repeating in the current 
-- pattern & track from line 0 to the pattern end)

local pattern_iter = renoise.song().pattern_iterator

local pattern_index =  renoise.song().selected_pattern_index
local track_index =  renoise.song().selected_track_index
local instrument_index = renoise.song().selected_instrument_index

local EMPTY_VOLUME = renoise.PatternTrackLine.EMPTY_VOLUME
local EMPTY_INSTRUMENT = renoise.PatternTrackLine.EMPTY_INSTRUMENT

local arp_sequence = {
  {note="C-4", instrument = instrument_index, volume = 0x20}, 
  {note="E-4", instrument = instrument_index, volume = 0x40}, 
  {note="G-4", instrument = instrument_index, volume = 0x80}, 
  {note="OFF", instrument = EMPTY_INSTRUMENT, volume = EMPTY_VOLUME}, 
  {note="G-4", instrument = instrument_index, volume = EMPTY_VOLUME}, 
  {note="---", instrument = EMPTY_INSTRUMENT, volume = EMPTY_VOLUME}, 
  {note="E-4", instrument = instrument_index, volume = 0x40}, 
  {note="C-4", instrument = instrument_index, volume = 0x20}, 
}

for pos,line in pattern_iter:lines_in_pattern_track(pattern_index, track_index) do
  if not table.is_empty(line.note_columns) then

    local note_column = line.note_columns[1]
    note_column:clear()
    
    local arp_index = math.mod(pos.line - 1, #arp_sequence) + 1
    note_column.note_string = arp_sequence[arp_index].note
    note_column.instrument_value = arp_sequence[arp_index].instrument
    note_column.volume_value = arp_sequence[arp_index].volume
  end
end


-------------------------------------------------------------------------------
-- renoise.SampleBuffer
-------------------------------------------------------------------------------

-- modify the selected sample

local sample_buffer = renoise.song().selected_sample.sample_buffer

-- check if sample data is preset at all first
if (sample_buffer.has_sample_data) then

  -- modify sample data in the selection (defaults to the whole sample)
  for channel = 1, sample_buffer.number_of_channels do
    for frame = sample_buffer.selection_start, sample_buffer.selection_end do
      local value = sample_buffer:sample_data(channel, frame)
      value = -value -- do something with the value
      sample_buffer:set_sample_data(channel, frame, value)
    end
  end

  -- let renoise update sample overviews and caches. apply bit depth 
  -- quantization. create undo/redo data if needed...
  sample_buffer:finalize_sample_data_changes()

else
  renoise.app():show_warning("No sample preset...")
end


-------------------------------------------------------------------------------
-- generate a new sample

local selected_sample = renoise.song().selected_sample
local sample_buffer = selected_sample.sample_buffer

-- create new or overwrite sample data for our sound:
local sample_rate = 44100
local num_channels = 1
local bit_depth = 32
local num_frames = sample_rate / 2

local allocation_succeeded = sample_buffer:create_sample_data(
  sample_rate, bit_depth, num_channels, num_frames)
  
-- check for allocation failures
if (not allocation_succeeded) then
  renoise.app():show_error("Out of memory. Failed to allocate sample data")
  return
end

-- fill in the sample data with an amazing zapp sound
for channel = 1,num_channels do
  for frame = 1,num_frames do
    local sample_value = math.sin(num_frames / frame)
    sample_buffer:set_sample_data(channel, frame, sample_value)
  end
end

-- let renoise update sample overviews and caches. apply bit depth 
-- quantization. create undo/redo data if needed...
sample_buffer:finalize_sample_data_changes()

-- setup a pingpong loop for our new sample
selected_sample.loop_mode = renoise.Sample.LOOP_MODE_PING_PONG
selected_sample.loop_start = 1
selected_sample.loop_end = num_frames


-------------------------------------------------------------------------------
-- renoise.Midi
-------------------------------------------------------------------------------

-- midi input listener (function callback)

local inputs = renoise.Midi.available_input_devices()
local midi_device = nil

if not table.is_empty(inputs) then
  local device_name = inputs[1]
  
  local function midi_callback(message)
    assert(#message == 3)
    assert(message[1] >= 0 and message[1] <= 0xff)
    assert(message[2] >= 0 and message[2] <= 0xff)    
    assert(message[3] >= 0 and message[3] <= 0xff)
    
    print(("%s: got MIDI %X %X %X"):format(device_name, 
      message[1], message[2], message[3]))
  end

  -- note: sysex callback would be a optional 2nd arg...
  midi_device = renoise.Midi.create_input_device(
    device_name, midi_callback)
  
  -- stop dumping with 'midi_device:close()' ...
end


-------------------------------------------------------------------------------
-- midi input and sysex listener (class callbacks)

class "MidiDumper"
  function MidiDumper:__init(device_name)
    self.device_name = device_name
  end
  
  function MidiDumper:start()
    self.device = renoise.Midi.create_input_device(
      self.device_name, 
      { self, MidiDumper.midi_callback }, 
      { MidiDumper.sysex_callback, self }
    )
  end
  
  function MidiDumper:stop()
    if self.device then 
      self.device:close()
      self.device = nil
    end
  end
  
  function MidiDumper:midi_callback(message)
    print(("%s: MidiDumper got MIDI %X %X %X"):format(
      self.device_name, message[1], message[2], message[3]))
  end

  function MidiDumper:sysex_callback(message)
    print(("%s: MidiDumper got SYSEX with %d bytes"):format(
      self.device_name, #message))
  end
  
  
local inputs = renoise.Midi.available_input_devices()

if not table.is_empty(inputs) then
  local device_name = inputs[1]
  
  midi_dumper = MidiDumper(device_name)
  midi_dumper:start()
  
  -- will dump till midi_dumper:stop() is called or the MidiDumber object 
  -- is garbage collected ...
end


-------------------------------------------------------------------------------
-- midi output 

local outputs = renoise.Midi.available_output_devices()

if not table.is_empty(outputs) then
  local device_name = outputs[1]
  midi_device = renoise.Midi.create_output_device(device_name)
  
  -- note on
  midi_device:send {0x90, 0x10, 0x7F}
  -- sysex (MMC start)
  midi_device:send {0xF0, 0x7F, 0x00, 0x06, 0x02, 0xF7}
 
  -- no longer need the device...
  midi_device:close()  
end


-------------------------------------------------------------------------------
-- renoise.Socket
-------------------------------------------------------------------------------

-- HTTP / GET client

-- create a TCP socket and connect it to www.wurst.com, http
local client, socket_error = renoise.Socket.create_client(
  "www.wurst.com", 80, renoise.Socket.PROTOCOL_TCP)
   
if socket_error then 
 renoise.app():show_warning(socket_error)
 return
end

-- request something
local succeeded, socket_error = 
  client:send("GET / HTTP/1.0\n\n")

if socket_error then 
 renoise.app():show_warning(socket_error)
 return
end

-- receive something and show what we got
local receive_timeout = 500

local message, socket_error = 
  client:receive(receive_timeout)

if socket_error then 
 renoise.app():show_warning(socket_error)
else
 renoise.app():show_prompt(
   "GET / HTTP/1.0 response", 
   message, 
   {"OK"}
 )
end


-------------------------------------------------------------------------------
-- echo udp server (using a table as notifier):

local server, socket_error = renoise.Socket.create_server(
  "localhost", 1025, renoise.Socket.PROTOCOL_UDP)
   
if socket_error then 
  app:show_warning(
     "Failed to start the echo server: " .. socket_error)
else
  server:run {
    socket_error = function(socket_error)
      renoise.app():show_warning(socket_error)
    end,
    
    socket_accepted = function(socket)
      print(("client %s:%d connected"):format(
        socket.peer_address, socket.peer_port))
    end,
  
    socket_message = function(socket, message)
      print(("client %s:%d sent '%s'"):format(
        socket.peer_address, socket.peer_port,  message))
      -- simply sent the message back      
      socket:send(message)
    end    
  }
end

-- will run and echo as long as the script runs...


-------------------------------------------------------------------------------
-- echo TCP server (using a class as notifier):

class "EchoServer"
  function EchoServer:__init(port)
   -- create a server socket
   local server, socket_error = 
     renoise.Socket.create_server("localhost", port)
     
   if socket_error then 
     app:show_warning(
       "Failed to start the echo server: " .. socket_error)
   else
     -- start running
     self.server = server
     self.server:run(self)
   end
  end

  function EchoServer:socket_error(socket_error)
    renoise.app():show_warning(socket_error)
  end
  
  function EchoServer:socket_accepted(socket)
    print(("client %s:%d connected"):format(
      socket.peer_address, socket.peer_port))
  end

  function EchoServer:socket_message(socket, message)
    print(("client %s:%d sent '%s'"):format(
      socket.peer_address, socket.peer_port,  message))
    -- simply sent the message back      
    socket:send(message)
  end
  
-- create and run the echo server on port 1025
local echo_server = EchoServer(1025)

-- will run and echo as long as the script runs or the EchoServer 
-- object is garbage collected...


--[[---------------------------------------------------------------------------
---------------------------------------------------------------------------]]--


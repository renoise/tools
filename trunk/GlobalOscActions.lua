--[[============================================================================

 GlobalOscActions.lua

 DO NOT EDIT THIS FILE IN THE RENOISE RESOURCE FOLDER! UPDATING RENOISE WILL
 TRASH YOUR MODIFICATIONS!
 
 TO EXTEND THE DEFAULT OSC IMPLEMENTATION, COPY THIS FILE TO THE RENOISE 
 PREFERENCES SCRIPT FOLDER, THEN DO YOUR CHANGES THERE.

============================================================================]]--

--[[

 This file defines Renoise's default OSC server implementation. Besides the 
 messages and patterns you find here, Renoise already processes a few realtime 
 critical messages internally. Those will never be triggered here, and thus can
 not be overloaded here:
 
 
 ---- Realtime Messages
 
 /renoise/trigger/midi(message(u/int32/64))
 
 /renoise/trigger/note_on(instr(int32/64), track(int32/64), 
   note(int32/64), velocity(int32/64))
   
 /renoise/trigger/note_off(instr(int32/64), track(int32/64), 
   note(int32/64))

 
 ---- Message Format
 
 All other messages are handled in this script. 
 
 The message arguments are passed to the process function as a table 
 (array) of:

 argument = {
   tag, -- (OSC type tag. See http://opensoundcontrol.org/spec-1_0)
   value -- (OSC value as lua type: nil, boolean, number or a string)
 }
 
 Please note that the message patterns are strings !without! the "/renoise" 
 prefix in this file. But the prefix must be specified when sending something 
 to Renoise. Some valid message examples are:
 
 /renoise/trigger/midi (handled internally)
 /renoise/transport/start (handled here)
 ...
 
 
 ---- Remote evaluation of Lua expressions via OSC
 
 With the OSC message "/renoise/evaluate" you can evaluate Lua expressions 
 remotely, and thus do "anything" the Renoise Lua API offers remotely. This 
 way you don't need to edit this file in order to extend Renoise's OSC 
 implementation, but can do so in your client.
 
 "/renoise/evaluate" expects exactly one argument, the to be evaluated 
 Lua expression, and will run the expression in a custom, safe Lua environment. 
 This custom environment is a sandbox which only allows access to some global 
 Lua functions and the renoise.XXX modules. This means you can not change any 
 globals or locals from this script. Please see below (evaluate_env) for the 
 complete list of allowed functions and modules. 
 
]]


--------------------------------------------------------------------------------
-- Message Registration
--------------------------------------------------------------------------------

local global_action_pattern_map = table.create{}

local track_action_pattern_map = table.create{}
local track_action_pattern_map_prefix = "/song/track"


-- argument

-- helper function to define a message argument for an action.
-- name is only needed when generating a list of available messages for the 
-- user. type is the expected lua type name for the OSC argument, NOT the OSC 
-- type tag. e.g. argument("bpm", "number")

local function argument(name, type)
  return { name = name, type = type }
end


-- add_action

-- register a global Renoise OSC message
-- info = {
--   pattern,     -> required. OSC message pattern like "/transport/start"
--   description, -> optional. string which describes the action
--   arguments    -> optional. table of arguments (see function 'argument')
--   handler      -> required. function which applies the action.
-- }

local function add_action(map, info)

  -- validate actions, help finding common errors and typos
  if not (type(info.pattern) == "string" and 
          type(info.handler) == "function") then
    error("An OSC action needs at least a 'pattern' and "..
      "'handler' function property.")
  end
  
  if not (type(info.description) == "nil" or 
          type(info.description) == "string") then
    error(("OSC action '%s': OSC message description should not be "..
      "specified or should be a string"):format(info.pattern))
  end
  
  if not (type(info.arguments) == "nil" or 
          type(info.arguments) == "table") then
    error(("OSC action '%s': OSC arguments should not be specified or "..
      "should be a table"):format(info.pattern))
  end
    
  for _, argument in pairs(info.arguments or {}) do
    if (argument.type ~= "number" and 
        argument.type ~= "string" and
        argument.type ~= "boolean")
    then
      error(("OSC action '%s': unexpected argument type '%s'. "..
        "expected a lua type (number, string or boolean)"):format(
        info.pattern, argument.type or "nil"))
      end
  end
    
  if (map[info.pattern] ~= nil) then 
    error(("OSC pattern '%s' is already registered"):format(info.pattern))
  end
  
  -- register the action
  info.arguments = info.arguments or {}
  info.description = info.description or "No description available"

  map[info.pattern] = info
end
 

--------------------------------------------------------------------------------

local function add_global_action(info)
  add_action(global_action_pattern_map, info)
end


--------------------------------------------------------------------------------

local function add_track_action(info)
  add_action(track_action_pattern_map, info)
end


--------------------------------------------------------------------------------
-- Message Helpers
--------------------------------------------------------------------------------

-- clamp_value

local function clamp_value(value, min_value, max_value)
  return math.min(max_value, math.max(value, min_value))
end


--------------------------------------------------------------------------------
-- Global Messages
--------------------------------------------------------------------------------

-- environment for custom expressions via OSC. such expressions can only 
-- access a few "safe" globals and modules

local evaluate_env = {
  _VERSION = _G._VERSION,
  
  math = table.rcopy(_G.math),
  renoise = table.rcopy(_G.renoise),
  string = table.rcopy(_G.string),
  table = table.rcopy(_G.table),
  assert = _G.assert,
  error = _G.error,
  ipairs = _G.ipairs,
  next = _G.next,
  pairs = _G.pairs,
  pcall = _G.pcall,
  print = _G.print,
  select = _G.select,
  tonumber = _G.tonumber,
  tostring = _G.tostring,
  type = _G.type,
  unpack = _G.unpack,
  xpcall = _G.xpcall
}

-- compile and evaluate an expression in the evaluate_env sandbox

local function evaluate(expression)
  local eval_function, message = loadstring(expression)
  
  if (not eval_function) then 
    -- failed to compile
    return nil, message 
  
  else
    -- run and return the result...
    setfenv(eval_function, evaluate_env)
    return pcall(eval_function)
  end
end


--------------------------------------------------------------------------------

-- evaluate

add_global_action { 
  pattern = "/evaluate", 
  description = "Evaluate a custom Lua expression, like e.g.\n" ..
    "'renoise.song().transport.bpm = 234'",
  
  arguments = { argument("expression", "string") },
  handler = function(expression)
    print(("OSC Message: evaluating '%s'"):format(expression))

    local succeeded, error_message = evaluate(expression)
    if (not succeeded) then
      print(("*** expression failed: '%s'"):format(error_message))
    end
  end,
}


--------------------------------------------------------------------------------

-- /transport/

add_global_action { 
  pattern = "/transport/start", 
  description = "Start playback or restart playing the current pattern.",
  
  arguments = nil,
  handler = function()
    local play_mode = renoise.Transport.PLAYMODE_RESTART_PATTERN
    renoise.song().transport:start(play_mode)
  end,  
}

add_global_action { 
  pattern = "/transport/stop", 
  description = "Stop playback.",
  
  arguments = nil,
  handler = function()
    renoise.song().transport:stop()
  end,
}

add_global_action { 
  pattern = "/transport/continue", 
  description = "Continue playback.",
  
  arguments = nil,
  handler = function()
    local play_mode = renoise.Transport.PLAYMODE_CONTINUE_PATTERN
    renoise.song().transport:start(play_mode)
  end,
}


-- /transport/loop/

add_global_action { 
  pattern = "/transport/loop/pattern", 
  description = "Enable or disable looping the current pattern",
  
  arguments = { argument("enabled", "boolean") },
  handler = function(enabled)
    renoise.song().transport.loop_pattern = enabled
  end,
}

add_global_action { 
  pattern = "/transport/loop/block", 
  description = "Enable or disable pattern block looping",
  
  arguments = { argument("enabled", "boolean") },
  handler = function(enabled)
    renoise.song().transport.loop_block_enabled = enabled
  end,
}

add_global_action { 
  pattern = "/transport/loop/block_move_forwards", 
  description = "Move loop block one segment forwards",
  
  arguments = nil,
  handler = function()
    renoise.song().transport:loop_block_move_forwards()
  end,
}

add_global_action { 
  pattern = "/transport/loop/block_move_backwards", 
  description = "Move loop block one segment backwards",
  
  arguments = nil,
  handler = function()
    renoise.song().transport:loop_block_move_backwards()
  end,
}

add_global_action { 
  pattern = "/transport/loop/sequence", 
  description = "Disable or set a new sequence loop range",
  
  arguments = { argument("start", "number"), argument("end", "number") },
  handler = function(rstart, rend)
    local start_pos = renoise.song().transport.loop_start
    start_pos.line = 1; start_pos.sequence = clamp_value(rstart, 1, 
      renoise.song().transport.song_length.sequence)
    
    local end_pos = renoise.song().transport.loop_end
    end_pos.line = 1; end_pos.sequence =  clamp_value(rend + 1, 1, 
      renoise.song().transport.song_length.sequence + 1)

    renoise.song().transport.loop_range = {start_pos, end_pos}
  end,
}


-- /song/

add_global_action { 
  pattern = "/song/bpm", 
  description = "Set the songs current BPM [32-999]",
  
  arguments = { argument("bpm", "number") },
  handler = function(bpm)
    renoise.song().transport.bpm = clamp_value(bpm, 32, 999)
  end,
}

add_global_action {
  pattern = "/song/lpb", 
  description = "Set the songs current Lines Per Beat [1-255]",

  arguments = { argument("lpb", "number") }, 
  handler = function(lpb)
    renoise.song().transport.lpb = clamp_value(lpb, 1, 255)
  end,  
}

add_global_action {
  pattern = "/song/tpl", 
  description = "Set the songs current Ticks Per Line [1-16]",

  arguments = { argument("tpl", "number") }, 
  handler = function(tpl)
    renoise.song().transport.tpl = clamp_value(tpl, 1, 16)
  end,  
}


-- /song/edit/

add_global_action { 
  pattern = "/song/edit/mode", 
  description = "Set the songs global edit mode on or off",
  
  arguments = { argument("enabled", "boolean") },
  handler = function(enabled)
    renoise.song().transport.edit_mode = enabled
  end,
}

add_global_action { 
  pattern = "/song/edit/octave", 
  description = "Set the songs current octave [0-8]",
  
  arguments = { argument("octave", "number") },
  handler = function(octave)
    renoise.song().transport.octave = clamp_value(octave, 0, 8)
  end,
}

add_global_action { 
  pattern = "/song/edit/step", 
  description = "Set the songs current edit_step [0-8]",
  
  arguments = { argument("edit_step", "number") },
  handler = function(edit_step)
    renoise.song().transport.edit_step = clamp_value(edit_step, 0, 9)
  end,
}

add_global_action { 
  pattern = "/song/edit/pattern_follow", 
  description = "Enable or disable the global pattern follow mode",
  
  arguments = { argument("enabled", "boolean") },
  handler = function(enabled)
    renoise.song().transport.follow_player = enabled
  end,
}


-- /song/record/

add_global_action { 
  pattern = "/song/record/quantization", 
  description = "Enable or disable the global record quantization",
  
  arguments = { argument("enabled", "boolean") },
  handler = function(enabled)
    renoise.song().transport.record_quantize_enabled = enabled
  end,
}

add_global_action { 
  pattern = "/song/record/quantization_step", 
  description = "Set the global record quantization step [1-32]",
  
  arguments = { argument("step", "number") },
  handler = function(step)
    renoise.song().transport.record_quantize_lines = clamp_value(step, 1, 32)
  end,
}

add_global_action { 
  pattern = "/song/record/chord_mode", 
  description = "Enable or disable the global chord mode",
  
  arguments = { argument("enabled", "boolean") },
  handler = function(enabled)
    renoise.song().transport.chord_mode_enabled = enabled
  end,
}


--------------------------------------------------------------------------------
-- Track Mappings (/song/track/XXX/)
--------------------------------------------------------------------------------

-- pre_volume

add_track_action { 
  pattern = "/prefx_volume", 
  description = "Set the mixer pre FX volume [0, 1.41]",
  
  arguments = { argument("value", "number") },
  handler = function(track_index, value)
    if (track_index < #renoise.song().tracks) then
      local parameter = renoise.song().tracks[track_index].prefx_volume

      parameter.value = clamp_value(
        value, parameter.value_min, parameter.value_max)
    end
  end,
}

add_track_action { 
  pattern = "/prefx_volume_db", 
  description = "Set the mixer pre FX volume in dB [-200, 3]",
  
  arguments = { argument("value", "number") },
  handler = function(track_index, value)
    if (track_index < #renoise.song().tracks) then
      local parameter = renoise.song().tracks[track_index].prefx_volume

      parameter.value = clamp_value(
        math.db2lin(value), parameter.value_min, parameter.value_max)
    end
  end,
}

-- post_volume

add_track_action { 
  pattern = "/postfx_volume", 
  description = "Set the mixer post FX volume [0, 1.41]",
  
  arguments = { argument("value", "number") },
  handler = function(track_index, value)
    if (track_index < #renoise.song().tracks) then
      local parameter = renoise.song().tracks[track_index].postfx_volume

      parameter.value = clamp_value(
        value, parameter.value_min, parameter.value_max)
    end
  end,
}

add_track_action { 
  pattern = "/postfx_volume_db", 
  description = "Set the mixer post FX volume in dB [-200, 3]",
  
  arguments = { argument("value", "number") },
  handler = function(track_index, value)
    if (track_index < #renoise.song().tracks) then
      local parameter = renoise.song().tracks[track_index].postfx_volume

      parameter.value = clamp_value(
        math.db2lin(value), parameter.value_min, parameter.value_max)
    end
  end,
}


--------------------------------------------------------------------------------
-- Interface
--------------------------------------------------------------------------------

-- available_messages

-- called by Renoise to show info about all available messages in the 
-- OSC preferences pane

function available_messages()

  local maps = table.create()
  maps:insert{
    map = global_action_pattern_map, 
    scope = ""
  }
  maps:insert{
    map = track_action_pattern_map, 
    scope = track_action_pattern_map_prefix.."/XXX"
  }
  
  local ret = table.create()

  for _, map in pairs(maps) do
    for _, action in pairs(map.map) do
      local argument_types = table.create()
      for _, argument in pairs(action.arguments) do
        argument_types:insert(argument.type)
      end
      
      ret:insert {
        name = map.scope .. action.pattern,
        description = action.description,
        arguments = argument_types
      }
    end
  end
    
  return ret
end


--------------------------------------------------------------------------------

-- process_message

-- called by Renoise in order to process an OSC message. the returned boolean 
-- is only used for the OSC log view in the preferences  (handled = false will 
-- log messages as REJECTED) 
-- Lua runtime errors that may happen here, will never be shown as errors to 
-- the user, but only dumped to the Lua terminal in Renoise.

function process_message(pattern, arguments)

  -- global pattern match
  local action = global_action_pattern_map[pattern]
  local action_context = nil
  
  if (not action) then
    local _, _, index, track_pattern = pattern:find(
      track_action_pattern_map_prefix.."/(%d)(.*)")
  
    -- track pattern match
    if (index and track_pattern) then
      action = track_action_pattern_map[track_pattern]
      action_context = tonumber(index)
    end
  end
  
  -- found a matching pattern?
  if (action) then
    
    -- then check if the arguments match
    local arg_match = false
    local arg_values = table.create{}
      
    if (action_context) then
      arg_values:insert(action_context)
    end
    
    if (#action.arguments == #arguments) then
      arg_match = true

      -- check argument types
      for i = 1, #arguments do
        if (action.arguments[i].type == type(arguments[i].value)) then 
          arg_values:insert(arguments[i].value)
        else
          arg_match = false
          break
        end
      end
    end
    
    -- and invoke the action
    if (arg_match) then
      action.handler(unpack(arg_values))
      return true -- handled
    end
  end
    
  return false -- not handled
end

